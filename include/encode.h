#ifndef __ENCODE_H__
#define __ENCODE_H__

#include <stdlib.h>
#include <string.h>

#define KEY_LEN 16

static unsigned char keydata[8][KEY_LEN] =
{
 {0xd2,0x8f,0xed,0x4f,0x20,0x28,0xb5,0x64,0x47,0x0d,0x25,0xb0,0x84,0x11,0x6e,0xad},
 {0x7c,0x50,0x4f,0x29,0x8b,0x61,0x06,0x9c,0xf9,0xfa,0xfb,0xd0,0xca,0x0b,0x14,0x39},
 {0x39,0xe3,0x6b,0xe0,0xf2,0x48,0x1f,0xd4,0x28,0xcb,0x52,0x3e,0x93,0x61,0x3d,0xec},
 {0xe0,0x3d,0xf8,0x17,0xa7,0xb6,0x3d,0xad,0x62,0x53,0xc8,0x82,0xcc,0xc8,0x4f,0x45},
 {0xfb,0xfa,0x58,0x77,0xf1,0x81,0x35,0x4d,0x77,0x91,0x7e,0x5e,0x86,0xe7,0x25,0x0d},
 {0x1a,0xd1,0xd0,0x01,0xcb,0x71,0x42,0x30,0x99,0x6a,0x6b,0xe8,0x66,0xd6,0x88,0x1d},
 {0x05,0x36,0xee,0x70,0x70,0x1e,0x8d,0x2f,0x55,0xad,0xaa,0x2c,0xdb,0x60,0x96,0xd7},
 {0x61,0x4f,0x4a,0x76,0x76,0xd4,0x82,0x68,0xcb,0x0b,0x57,0x33,0xb7,0x85,0xa5,0x63}
};

/* simple xor crypt */
static inline void xor_crypt(void *data, int len, int keyindex)
{
  unsigned char *p = (unsigned char *)data;
  const unsigned char *key = keydata[keyindex];
  const int kmask = (KEY_LEN) - 1;
  int k=0;

  while( len > 0 )
  {
    *p ^= key[k];

    ++p;
    k = (k+1) & kmask;
    --len;
  }
}

#define salt_to_key(s) ((salt>>3)&(8-1))

/* add a little salt and encode */
static inline int encode(unsigned char *out, const void *data, int len)
{
  unsigned char salt = rand() & 0xff;

  out[0] = salt;

  memcpy(out+1, data, len);

  xor_crypt(out+1, len, salt_to_key(salt));

  return len+1;
}

static inline int decode(unsigned char *out, const void *data, int len)
{
  unsigned char salt = ((unsigned char *)data)[0];

  memcpy(out, data+1, len-1);

  xor_crypt(out, len-1, salt_to_key(salt));

  return len-1;
}


#endif  /*__ENCODE_H__*/
